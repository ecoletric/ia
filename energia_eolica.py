# -*- coding: utf-8 -*-
"""energia eolica.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1HSpK8VcUhwFBEShTYPAJquyRancgzGLu
"""

import numpy as np
import pandas as pd

df = pd.read_csv('Location2.csv')


df['Time']=pd.to_datetime(df['Time'])

df['Time'] = df['Time'].dt.strftime('%d-%m')
df = df.groupby('Time').mean().reset_index()

df=df.set_index('Time')


df

def df_to_Xy(df,lag):
    df_as_np=df.to_numpy()
    X=[]
    y=[]
    for i in range(len(df)-lag):
        rows=[[r] for r in df_as_np[i:i+lag]]
        label=df_as_np[i+lag,df.columns.get_loc('Power')]
        X.append(rows)
        y.append(label)
    return np.array(X), np.array(y)

X,y=df_to_Xy(df,50)

X.shape,y.shape

train_idx=int(len(X)*0.8)
val_idx=int(len(X)*0.9)

X_train,y_train=X[:train_idx] ,y[:train_idx]
X_val,y_val=X[train_idx:val_idx], y[train_idx:val_idx]
X_test,y_test=X[val_idx:], y[val_idx:]

X_train=X_train.reshape(X_train.shape[0], X_train.shape[1], -1)
X_val=X_val.reshape(X_val.shape[0], X_val.shape[1], -1)
X_test=X_test.reshape(X_test.shape[0], X_test.shape[1], -1)

X_train.shape, y_train.shape, X_val.shape, y_val.shape, X_test.shape, y_test.shape

from keras.models import Sequential
from keras.layers import LSTM, Dense, InputLayer
from keras.optimizers import Adam

model = Sequential()
model.add(LSTM(units=64, input_shape=(50, 9)))
model.add(Dense(units=1, activation='sigmoid'))

model.summary()

model.compile(optimizer='adam', loss='binary_crossentropy', metrics=['accuracy'])
model.fit(X_train, y_train, epochs=100, batch_size=64, validation_data=(X_val, y_val))

test_predictions=model.predict(X_test)
test_predictions = (test_predictions > 0.5).astype(int)

from sklearn import metrics
import seaborn as sns

evaluation = model.evaluate(X_test, y_test)
y_test_binary = (y_test > 0.5).astype(int)


# This will give you the loss value and accuracy on the test set
print(f"Test Loss: {evaluation[0]}")
print(f"Test Accuracy: {evaluation[1]}")
print(f"f1 Score: {metrics.f1_score(test_predictions,y_test_binary)}")

cm=metrics.confusion_matrix(test_predictions,y_test_binary)
cm=(100*cm/cm.sum())

sns.heatmap(cm,annot=True,cmap='Reds',fmt='.2f')